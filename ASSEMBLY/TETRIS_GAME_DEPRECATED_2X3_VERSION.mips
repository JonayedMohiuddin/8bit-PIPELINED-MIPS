# CLASSICAL TETRIS GAME
# MADE BY : JONAYED MOHIUDDIN 
# EMAIL   : jonayedmohiuddin@gmail.com
# Intended to run by the 8-bit mips here : https://github.com/JonayedMohiuddin/8bit_MIPS

# CONTROLS : d/D = RIGHT, s/S = DOWN, a/A = LEFT
# DISPLAY : 16 x 32 LED matrix, 3 x 7 digit display and TTY text screen 
# !! DISPLAY Caution: x is 5 bit and y is 4 bit 

# IO PORTS:
# 0($io) => X ENABLE + DATA
# 1($io) => Y ENABLE + DATA
# 2($io) => UPDATE FLAG
# 3($io) => FLUSH FLAG
# 4($io) => KEYBOARD INPUT
# 5($io) => TEXT OUTPUT (TTY)
# ...    => UNUSED
# 13($io) => SIGNED DECIMAL OUTPUT DISPLAY (7 SEGMENT DISPLAY)
# 14($io) => DEBUG OUTPUT 
# 15($io) => RAND INPUT

# Control Mapping:
# 011 = w/W = UP = 3
# 100 = d/D = RIGHT = 4
# 111 = s/S = DOWN = 7
# 001 = a/A = LEFT = 1

# MEMORY MAPPING:
# 000 - 127 : GAME DATA [SCREEN SIMULATION]
# 128 - 159 : OTHER DATA + STACK
# 160 - 175 : IO PORTS
# 192 - 207 : OTHER DATA
# 208 - 255 : GAME DATA [BASE SHAPE SPAWN DATA]

# SCREEN SIMULATION ARRAY STRUCTURE:
# 0 - 127 : 16 x 8 SCREEN SIMULATION
# 0 = EMPTY, 1 = STATIC, 2 = MOVING

#                                SHAPES
#
#   |+||+|   |+|               |+|         |+||+|     |+||+|         |+|
#   |+||+|   |+||+||+|   |+||+||+|      |+||+|           |+||+|   |+||+||+|
#     0 (O)      1 (L)       2 (J)          3 (S)         4 (Z)       5 (T)
#    SHAPE INDEX BASE MEMORY AT $shape


# REGISTERS:
# $zero, $sp, $io, $t0, $t1, $t2, $t3, $t4, $v0, $v1, $v2, $v3, $s0, $s1, $s2, $s3

# NON STANDARD MIPS INSTRUCTIONS:
# RENAMING REGISTERS FOR EASE OF USE
# USE @ TO RENAME REGISTERS [@ old_name new_name]
@ s3 shape     # shape memory space base index
@ s2 score 
@ s1 sim       # simulation memory space base index
@ s0 shape     # memory location of the shape (bottom left corner)

main:
    # INITIALIZATION
    addi $score, $zero, 0   # reset score
    addi $shape, $zero, -1  # reset shape location

    j game_loop


game_loop:    
    ### A RIGHT WALL TO SHOW SCREEN END AT (8, ...) CORD
    addi $t0, $zero, 8 # x = 8
    addi $t1, $zero, 0 # y = 0
    addi $t2, $zero, 15 # y = 15 max y limit
    j draw_screen_border_loop
    after_draw_screen_border_loop:

    ### SPAWN A SHAPE
    addi $t0, $zero, -1
    beq $shape, $t0, spawn_shape  # if shape is static, spawn a new shape [shape is static if shapeX = -1]
    after_spawn_shape:

    ### MAP MEMORY SPACE TO SCREEN SPACE
    addi $t0, $zero, 0  # x memory indexing (inner loop)
    addi $v1, $zero, 0  # X : actual x value (inner loop)
    addi $t1, $zero, 0  # y , Y : memory indexing = actual value (outer loop)
    addi $t2, $zero, 8  # max inner loop index
    addi $t3, $zero, 16 # max outer loop index 
    j draw_screen_simulation_outer_loop
    after_draw_screen_simulation_outer_loop:

    ### CHECK IF SHAPE CAN MOVE DOWN [STORES RESULT IN $v3]
    j check_if_shape_move_down_valid
    after_check_if_shape_move_down_valid:

    ### MOVE SHAPE DOWN
    bneq $v3, $zero, move_shape_down
    after_move_shape_down:

    # ### FLUSH DISPLAY
    sw $zero, 3($io)  # flush display

    j game_loop

# COMMON SHAPE STRUCTURE :
# | D | E | F |
# | A | B | C |
check_if_shape_move_down_valid:
    # $v3 will be the is_valid flag
    addi $v3, $zero, 1  # assume valid [1 = valid, 0 = invalid]
    addi $t1, $zero, 2  # moving state is 2

    addi $t0, $shape, 0 # mem location of shape
    lw $t2, 0($shape) # A
    beq $t2, $t1, check_if_shape_move_down_valid_A
    after_check_if_shape_move_down_valid_A:

    addi $t0, $shape, 16  # move to B
    lw $t2, 0($t0) # B
    beq $t2, $t1, check_if_shape_move_down_valid_B
    after_check_if_shape_move_down_valid_B:

    addi $t0, $shape, 32  # move to C
    lw $t2, 0($t0) # C
    beq $t2, $t1, check_if_shape_move_down_valid_C
    after_check_if_shape_move_down_valid_C:

    addi $t0, $shape, 1  # move to D
    lw $t2, 0($t0) # D
    beq $t2, $t1, check_if_shape_move_down_valid_D
    after_check_if_shape_move_down_valid_D:

    addi $t0, $shape, 17  # move to E
    lw $t2, 0($t0) # E
    beq $t2, $t1, check_if_shape_move_down_valid_E
    after_check_if_shape_move_down_valid_E:

    addi $t0, $shape, 33  # move to F
    lw $t2, 0($t0) # F
    beq $t2, $t1, check_if_shape_move_down_valid_F
    after_check_if_shape_move_down_valid_F:

    j after_check_if_shape_move_down_valid         # SHAPE CAN MOVE DOWN

    shape_move_down_not_valid:
    addi $v3, $zero, 0  # invalid move
    j after_check_if_shape_move_down_valid         # SORRY, SHAPE CAN'T MOVE DOWN


check_if_shape_move_down_valid_A:
    andi $t3, $t0, 15                                   # after removing last 4 bits if we get zero that means our shape is already at floor
    beq $t3, $zero, shape_move_down_not_valid           
    addi $t0, $shape, -1                                # move A down
    lw $t2, 0($t0)                                      # check if A's new location is empty
    beq $t2, $v3, shape_move_down_not_valid             # using $v3 as temporary value of 1 :)            
    j after_check_if_shape_move_down_valid_A

check_if_shape_move_down_valid_B:
    andi $t3, $t0, 15                                   # after removing last 4 bits if we get zero that means our shape is already at floor
    beq $t3, $zero, shape_move_down_not_valid           
    addi $t0, $shape, 15                                # move B down
    lw $t2, 0($t0)                                      # check if B's new location is empty
    beq $t2, $v3, shape_move_down_not_valid             # using $v3 as temporary value of 1 :)            
    j after_check_if_shape_move_down_valid_B

check_if_shape_move_down_valid_C:
    andi $t3, $t0, 15                                   # after removing last 4 bits if we get zero that means our shape is already at floor
    beq $t3, $zero, shape_move_down_not_valid           
    addi $t0, $shape, 31                                # move C down
    lw $t2, 0($t0)                                      # check if C's new location is empty
    beq $t2, $v3, shape_move_down_not_valid             # using $v3 as temporary value of 1 :)            
    j after_check_if_shape_move_down_valid_C

check_if_shape_move_down_valid_D:
    andi $t3, $t0, 15                                   # after removing last 4 bits if we get zero that means our shape is already at floor
    beq $t3, $zero, shape_move_down_not_valid           
    addi $t0, $shape, 1                                 # move D down
    lw $t2, 0($t0)                                      # check if D's new location is empty
    beq $t2, $v3, shape_move_down_not_valid             # using $v3 as temporary value of 1 :)            
    j after_check_if_shape_move_down_valid_D

check_if_shape_move_down_valid_E:
    andi $t3, $t0, 15                                   # after removing last 4 bits if we get zero that means our shape is already at floor
    beq $t3, $zero, shape_move_down_not_valid           
    addi $t0, $shape, 17                                # move E down
    lw $t2, 0($t0)                                      # check if E's new location is empty
    beq $t2, $v3, shape_move_down_not_valid             # using $v3 as temporary value of 1 :)            
    j after_check_if_shape_move_down_valid_E

check_if_shape_move_down_valid_F:
    andi $t3, $t0, 15                                   # after removing last 4 bits if we get zero that means our shape is already at floor
    beq $t3, $zero, shape_move_down_not_valid           
    addi $t0, $shape, 33                                # move F down
    lw $t2, 0($t0)                                      # check if F's new location is empty
    beq $t2, $v3, shape_move_down_not_valid             # using $v3 as temporary value of 1 :)            
    j after_check_if_shape_move_down_valid_F

# COMMON SHAPE STRUCTURE :
# | D | E | F |
# | A | B | C |
move_shape_down:
    # shapeX and shapeY are the memory location of bottom of the shape
    addi $t1, $zero, 2  # moving state is 2
    # moving down in memory space means : 
    # [IMPORTANT] memory_location = memory_location - 1
    addi $t0, $shape, 0 # mem location of shape
    lw $t2, 0($shape) # A
    beq $t2, $t1, move_shape_down_A
    after_move_shape_down_A:

    addi $t0, $shape, 16  # move to B
    lw $t2, 0($t0) # B
    beq $t2, $t1, move_shape_down_B
    after_move_shape_down_B:

    addi $t0, $shape, 32  # move to C
    lw $t2, 0($t0) # C
    beq $t2, $t1, move_shape_down_C
    after_move_shape_down_C:

    addi $t0, $shape, 1  # move to D
    lw $t2, 0($t0) # D
    beq $t2, $t1, move_shape_down_D
    after_move_shape_down_D:

    addi $t0, $shape, 17  # move to E
    lw $t2, 0($t0) # E
    beq $t2, $t1, move_shape_down_E
    after_move_shape_down_E:

    addi $t0, $shape, 33  # move to F
    lw $t2, 0($t0) # F
    beq $t2, $t1, move_shape_down_F
    after_move_shape_down_F:

    addi $shape, $shape, -1 # moved shape down

    j after_move_shape_down

move_shape_down_A:
    sw $zero, 0($t0)   # make A empty
    addi $t0, $t0, -1  # move A's pointer down
    sw $t1, 0($t0)     # mark A's new location as moving
    j after_move_shape_down_A

move_shape_down_B:
    sw $zero, 0($t0)   # make B empty
    addi $t0, $t0, -1  # move B's pointer down
    sw $t1, 0($t0)     # mark B's new location as moving
    j after_move_shape_down_B

move_shape_down_C:
    sw $zero, 0($t0)   # make C empty
    addi $t0, $t0, -1  # move C's pointer down
    sw $t1, 0($t0)     # mark C's new location as moving
    j after_move_shape_down_C

move_shape_down_D:  
    sw $zero, 0($t0)   # make D empty
    addi $t0, $t0, -1  # move D's pointer down
    sw $t1, 0($t0)     # mark D's new location as moving
    j after_move_shape_down_D

move_shape_down_E:
    sw $zero, 0($t0)   # make E empty
    addi $t0, $t0, -1  # move E's pointer down
    sw $t1, 0($t0)     # mark E's new location as moving
    j after_move_shape_down_E

move_shape_down_F:  
    sw $zero, 0($t0)   # make F empty
    addi $t0, $t0, -1  # move F's pointer down
    sw $t1, 0($t0)     # mark F's new location as moving
    j after_move_shape_down_F

draw_screen_simulation_outer_loop:
    draw_screen_simulation_inner_loop:
        add $t4, $t0, $t1 # memory index
        lw $v0, 0($t4)
        bneq $v0, $zero, send_shape_pixel_to_display
        after_send_pixel_to_display:
        add $t0, $t0, $t3
        addi $v1, $v1, 1
        beq $v1, $t2, after_draw_screen_simulation_inner_loop
        j draw_screen_simulation_inner_loop

    after_draw_screen_simulation_inner_loop:

    addi $t0, $zero, 0  # reset inner loop index
    addi $v1, $zero, 0    # reset x value

    addi $t1, $t1, 1   # increment outer loop mem value
    beq $t1, $t3, after_draw_screen_simulation_outer_loop
    j draw_screen_simulation_outer_loop


send_shape_pixel_to_display:
    sw $v1, 0($io)      # send x to display
    sw $t1, 1($io)      # send y to display
    sw $zero, 2($io)    # update display
    j after_send_pixel_to_display


spawn_shape:
    # spawn cords are fixed (3, 14) bottom left corner of 2 x 3 spawn zone
    addi $t1, $zero, 2  # moving shape

    j spawn_shape_o
    after_spawn_shape_specific:

    # bottom-left corner is the reference point
    addi $shape, $zero, 62 

    j after_spawn_shape

# COMMON SHAPE SPAWN CODE 
# | D | E | F |
# | A | B | C |
# spawn_common_shape:
#     addi $t0, $zero, 62 # (3, 14) at memory = 3 * 16 + 14 = 62
#     sw $t1, 0($t0)      # set the shape at (3, 14)
#     addi $t0, $zero, 63 # (3, 15) at memory = 3 * 16 + 15 = 63
#     sw $t1, 0($t0)      # set the shape at (3, 15)
#     addi $t0, $zero, 78 # (4, 14) at memory = 4 * 16 + 14 = 78
#     sw $t1, 0($t0)      # set the shape at (4, 14)
#     addi $t0, $zero, 79 # (4, 15) at memory = 4 * 16 + 15 = 79
#     sw $t1, 0($t0)      # set the shape at (4, 15)
#     addi $t0, $zero, 94 # (5, 14) at memory = 5 * 16 + 14 = 94
#     sw $t1, 0($t0)      # set the shape at (5, 14)
#     addi $t0, $zero, 95 # (5, 15) at memory = 5 * 16 + 15 = 95
#     sw $t1, 0($t0)      # set the shape at (5, 15)

#     j after_spawn_shape_specific

spawn_shape_o:
    addi $t0, $zero, 62 # (3, 14) at memory = 3 * 16 + 14 = 62
    sw $t1, 0($t0)      # set the shape at (3, 14)
    addi $t0, $zero, 63 # (3, 15) at memory = 3 * 16 + 15 = 63
    sw $t1, 0($t0)      # set the shape at (3, 15)
    addi $t0, $zero, 78 # (4, 14) at memory = 4 * 16 + 14 = 78
    sw $t1, 0($t0)      # set the shape at (4, 14)
    addi $t0, $zero, 79 # (4, 15) at memory = 4 * 16 + 15 = 79
    sw $t1, 0($t0)      # set the shape at (4, 15)
    addi $t0, $zero, 94 # (5, 14) at memory = 5 * 16 + 14 = 94
    sw $t1, 0($t0)      # set the shape at (5, 14)
    addi $t0, $zero, 95 # (5, 15) at memory = 5 * 16 + 15 = 95
    sw $t1, 0($t0)      # set the shape at (5, 15)

    j after_spawn_shape_specific


draw_screen_border_loop:
    sw $t0, 0($io)    # send x to display
    sw $t1, 1($io)    # send y to display
    sw $zero, 2($io)  # update display
    beq $t1, $t2, after_draw_screen_border_loop
    addi $t1, $t1, 1
    j draw_screen_border_loop

exit:
