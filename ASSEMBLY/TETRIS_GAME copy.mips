# CLASSICAL TETRIS GAME
# MADE BY : JONAYED MOHIUDDIN 
# EMAIL   : jonayedmohiuddin@gmail.com
# Intended to run by the 8-bit mips here : https://github.com/JonayedMohiuddin/8bit_MIPS

# CONTROLS : d/D = RIGHT, s/S = DOWN, a/A = LEFT
# DISPLAY : 16 x 32 LED matrix, 3 x 7 digit display and TTY text screen 
# !! DISPLAY Caution: x is 5 bit and y is 4 bit 

# IO PORTS:
# 0($io) => X ENABLE + DATA
# 1($io) => Y ENABLE + DATA
# 2($io) => UPDATE FLAG
# 3($io) => FLUSH FLAG
# 4($io) => KEYBOARD INPUT
# 5($io) => TEXT OUTPUT (TTY)
# ...    => UNUSED
# 13($io) => SIGNED DECIMAL OUTPUT DISPLAY (7 SEGMENT DISPLAY)
# 14($io) => DEBUG OUTPUT 
# 15($io) => RAND INPUT

# Control Mapping:
# 011 = w/W = UP = 3
# 100 = d/D = RIGHT = 4
# 111 = s/S = DOWN = 7
# 001 = a/A = LEFT = 1

# MEMORY MAPPING:
# 000 - 127 : GAME DATA [SIMULATION]
# 128 - 239 : DATA + STACK
# 240 - 255 : IO PORTS

# SCREEN SIMULATION ARRAY STRUCTURE:
# 0 - 127 : 16 x 8 SCREEN SIMULATION (DROPS RIGHT TO LEFT)
# 0 = EMPTY, 1 = STATIC, 2 = MOVING
# Moving Down : -1 , Moving Left : -16 , Moving Right : +16

#                     SHAPES
#
#   |+||+|   |+|         |+|   |+||+|   |+|
#   |+||+|   |+||+|   |+||+|      |+|   |+|
#     O        L        J         7      I

# REGISTERS:
# $zero, $sp, $io, $t0, $t1, $t2, $t3, $t4, $v0, $v1, $v2, $v3, $s0, $s1, $s2, $s3

# NON STANDARD MIPS INSTRUCTIONS:
# RENAMING REGISTERS FOR EASE OF USE
# USE @ TO RENAME REGISTERS [@ old_name new_name]
@ s3 shape     # shape memory space base index
@ s2 score 
@ s1 sim       # simulation memory space base index
@ s0 shape     # memory location of the shape (bottom left corner)

main:
    # INITIALIZATION
    addi $score, $zero, 0   # reset score
    addi $shape, $zero, -1  # reset shape location

    j game_loop

#########################################################################
#####################         TODO        ###############################
#########################################################################
# 1. Keep single procedure for left/right just pass +16 or -16          #
# 2. Make use of the memory to screen loop for bottom row clearance     #
#########################################################################

game_loop:    
    ### A RIGHT WALL TO SHOW SCREEN END AT (8, ...) CORD
    addi $t0, $zero, 8 # x = 8
    addi $t1, $zero, 0 # y = 0
    addi $t2, $zero, 15 # y = 15 max y limit
    j draw_screen_border_loop
    after_draw_screen_border_loop:

    ### SPAWN A SHAPE
    addi $t0, $zero, -1
    beq $shape, $t0, spawn_shape  # if shape is static, spawn a new shape [shape is static if shapeX = -1]
    after_spawn_shape:

    ### MAP MEMORY SPACE TO SCREEN SPACE
    addi $t0, $zero, 0  # x memory indexing (inner loop)
    addi $v1, $zero, 0  # X : actual x value (inner loop)
    addi $t1, $zero, 0  # y , Y : memory indexing = actual value (outer loop)
    addi $t2, $zero, 8  # max inner loop index
    addi $t3, $zero, 16 # max outer loop index 
    j draw_screen_simulation_outer_loop
    after_draw_screen_simulation_outer_loop:

    ### CHECK IF SHAPE CAN MOVE DOWN [STORES RESULT IN $v3]
    j check_if_shape_move_down_valid
    after_check_if_shape_move_down_valid:

    ### MOVE SHAPE DOWN
    bneq $v3, $zero, move_shape_down
    after_move_shape_down:

    ### MOVE SHAPE LEFT/RIGHT
    addi $t4, $zero, -16
    # j move_shape_left_right
    after_move_shape_left_right:

    # ### FLUSH DISPLAY
    sw $zero, 3($io)  # flush display

    j game_loop

# COMMON SHAPE STRUCTURE :
# | C | D |
# | A | B |
check_if_shape_move_down_valid:
    # $v3 will be the is_valid flag
    addi $v3, $zero, 1  # assume valid [1 = valid, 0 = invalid]
    addi $t1, $zero, 2  # moving state is 2

    addi $t0, $shape, 0 # mem location of shape
    lw $t2, 0($shape) # A
    beq $t2, $t1, check_if_shape_move_down_valid_A
    after_check_if_shape_move_down_valid_A:

    addi $t0, $shape, 16  # move to B
    lw $t2, 0($t0) # B
    beq $t2, $t1, check_if_shape_move_down_valid_B
    after_check_if_shape_move_down_valid_B:

    addi $t0, $shape, 1  # move to C
    lw $t2, 0($t0) # D
    beq $t2, $t1, check_if_shape_move_down_valid_C
    after_check_if_shape_move_down_valid_C:

    addi $t0, $shape, 17  # move to D
    lw $t2, 0($t0) # E
    beq $t2, $t1, check_if_shape_move_down_valid_D
    after_check_if_shape_move_down_valid_D:

    j after_check_if_shape_move_down_valid         # SHAPE CAN MOVE DOWN

    shape_move_down_not_valid:
    addi $v3, $zero, 0  # invalid move
    j after_check_if_shape_move_down_valid         # SORRY, SHAPE CAN'T MOVE DOWN


check_if_shape_move_down_valid_A:
    andi $t3, $t0, 15                                   # after removing last 4 bits if we get zero that means our shape is already at floor
    beq $t3, $zero, shape_move_down_not_valid           
    addi $t0, $shape, -1                                # move A down
    lw $t2, 0($t0)                                      # check if A's new location is empty
    beq $t2, $v3, shape_move_down_not_valid             # using $v3 as temporary value of 1 :)            
    j after_check_if_shape_move_down_valid_A

check_if_shape_move_down_valid_B:
    andi $t3, $t0, 15                                   # after removing last 4 bits if we get zero that means our shape is already at floor
    beq $t3, $zero, shape_move_down_not_valid           
    addi $t0, $shape, 15                                # move B down
    lw $t2, 0($t0)                                      # check if B's new location is empty
    beq $t2, $v3, shape_move_down_not_valid             # using $v3 as temporary value of 1 :)            
    j after_check_if_shape_move_down_valid_B

check_if_shape_move_down_valid_C:
    andi $t3, $t0, 15                                   # after removing last 4 bits if we get zero that means our shape is already at floor
    beq $t3, $zero, shape_move_down_not_valid           
    addi $t0, $shape, 1                                 # move D down
    lw $t2, 0($t0)                                      # check if D's new location is empty
    beq $t2, $v3, shape_move_down_not_valid             # using $v3 as temporary value of 1 :)            
    j after_check_if_shape_move_down_valid_C

check_if_shape_move_down_valid_D:
    andi $t3, $t0, 15                                   # after removing last 4 bits if we get zero that means our shape is already at floor
    beq $t3, $zero, shape_move_down_not_valid           
    addi $t0, $shape, 17                                # move E down
    lw $t2, 0($t0)                                      # check if E's new location is empty
    beq $t2, $v3, shape_move_down_not_valid             # using $v3 as temporary value of 1 :)            
    j after_check_if_shape_move_down_valid_D


# COMMON SHAPE STRUCTURE :
# | C | D |
# | A | B |
move_shape_down:
    # shapeX and shapeY are the memory location of bottom of the shape
    addi $t1, $zero, 2  # moving state is 2
    # moving down in memory space means : 
    # [IMPORTANT] memory_location = memory_location - 1

    addi $t0, $shape, 0 # mem location of shape
    lw $t2, 0($shape) # A
    beq $t2, $t1, move_shape_down_A
    after_move_shape_down_A:

    addi $t0, $shape, 16  # move to B
    lw $t2, 0($t0) # B
    beq $t2, $t1, move_shape_down_B
    after_move_shape_down_B:

    addi $t0, $shape, 1  # move to C
    lw $t2, 0($t0) # C
    beq $t2, $t1, move_shape_down_C
    after_move_shape_down_C:

    addi $t0, $shape, 17  # move to D
    lw $t2, 0($t0) # D
    beq $t2, $t1, move_shape_down_D
    after_move_shape_down_D:

    addi $shape, $shape, -1 # moved shape down

    j after_move_shape_down
    
move_shape_down_A:
    sw $zero, 0($t0)   # make A empty
    addi $t0, $t0, -1  # move A's pointer down
    sw $t1, 0($t0)     # mark A's new location as moving
    j after_move_shape_down_A

move_shape_down_B:
    sw $zero, 0($t0)   # make B empty
    addi $t0, $t0, -1  # move B's pointer down
    sw $t1, 0($t0)     # mark B's new location as moving
    j after_move_shape_down_B

move_shape_down_C:
    sw $zero, 0($t0)   # make C empty
    addi $t0, $t0, -1  # move C's pointer down
    sw $t1, 0($t0)     # mark C's new location as moving
    j after_move_shape_down_C

move_shape_down_D:
    sw $zero, 0($t0)   # make D empty
    addi $t0, $t0, -1  # move D's pointer down
    sw $t1, 0($t0)     # mark D's new location as moving
    j after_move_shape_down_D



# COMMON SHAPE STRUCTURE :
# | C | D |
# | A | B |
# Move offset is set at $t4 (+16 or -16)
move_shape_left_right:
    addi $t1, $zero, 2  # moving state is 2

    addi $t0, $shape, 0                 # mem location of A
    lw $t2, 0($shape)                   # A
    beq $t2, $t1, move_shape_left_right_A
    after_move_shape_left_right_A:

    addi $t0, $shape, 16                # move to B
    lw $t2, 0($t0)                      # B
    beq $t2, $t1, move_shape_left_right_B
    after_move_shape_left_right_B:

    addi $t0, $shape, 1                # move to C
    lw $t2, 0($t0)                     # C
    beq $t2, $t1, move_shape_left_right_C
    after_move_shape_left_right_C:

    addi $t0, $shape, 17               # move to D
    lw $t2, 0($t0)                     # D
    beq $t2, $t1, move_shape_left_right_D
    after_move_shape_left_right_D:

    add $shape, $shape, $t4            # moved shape left/right

    j after_move_shape_left_right


move_shape_left_right_A:
    sw $zero, 0($t0)   # make A empty
    add $t0, $t0, $t4  # move A's pointer left/right
    sw $t1, 0($t0)     # mark A's new location as moving
    j after_move_shape_down_A

move_shape_left_right_B:
    sw $zero, 0($t0)   # make B empty
    add $t0, $t0, $t4  # move B's pointer left/right
    sw $t1, 0($t0)     # mark B's new location as moving
    j after_move_shape_down_B

move_shape_left_right_C:
    sw $zero, 0($t0)   # make C empty
    add $t0, $t0, $t4  # move C's pointer left/right
    sw $t1, 0($t0)     # mark C's new location as moving
    j after_move_shape_down_C

move_shape_left_right_D:
    sw $zero, 0($t0)   # make D empty
    add $t0, $t0, $t4  # move D's pointer left/right
    sw $t1, 0($t0)     # mark D's new location as moving
    j after_move_shape_down_D


draw_screen_simulation_outer_loop:
    draw_screen_simulation_inner_loop:
        add $t4, $t0, $t1 # memory index
        lw $v0, 0($t4)
        bneq $v0, $zero, send_shape_pixel_to_display
        after_send_pixel_to_display:
        add $t0, $t0, $t3
        addi $v1, $v1, 1
        beq $v1, $t2, after_draw_screen_simulation_inner_loop
        j draw_screen_simulation_inner_loop

    after_draw_screen_simulation_inner_loop:

    addi $t0, $zero, 0  # reset inner loop index
    addi $v1, $zero, 0    # reset x value

    addi $t1, $t1, 1   # increment outer loop mem value
    beq $t1, $t3, after_draw_screen_simulation_outer_loop
    j draw_screen_simulation_outer_loop


send_shape_pixel_to_display:
    sw $v1, 0($io)      # send x to display
    sw $t1, 1($io)      # send y to display
    sw $zero, 2($io)    # update display
    j after_send_pixel_to_display


spawn_shape:
    # spawn cords are fixed (3, 14) bottom left corner of 2 x 3 spawn zone
    addi $t1, $zero, 2  # moving shape

    # generate a random number between 0 - 7
    # number to shape mapping:
    # 0 = O, 1 = L, 2 = J, 3 = 7, 4 = I, 5 = O, 6 = L, 7 = J
    lw $t0, 15($io)     # get random number
    andi $t0, $t0, 7    # get last 3 bits

    addi $t2, $zero, 0
    beq $t0, $t2, spawn_shape_o
    addi $t2, $zero, 1
    beq $t0, $t2, spawn_shape_l
    addi $t2, $zero, 2
    beq $t0, $t2, spawn_shape_j
    addi $t2, $zero, 3
    beq $t0, $t2, spawn_shape_7
    addi $t2, $zero, 4
    beq $t0, $t2, spawn_shape_i
    addi $t2, $zero, 5
    beq $t0, $t2, spawn_shape_o
    addi $t2, $zero, 6
    beq $t0, $t2, spawn_shape_l
    addi $t2, $zero, 7
    beq $t0, $t2, spawn_shape_j

    j spawn_shape_o
    after_spawn_shape_specific:

    # bottom-left corner is the reference point
    addi $shape, $zero, 62 

    j after_spawn_shape

# COMMON SHAPE SPAWN CODE 
# | C | D |
# | A | B |
# spawn_common_shape:
#     addi $t0, $zero, 62 # (3, 14) at memory = 3 * 16 + 14 = 62   # A
#     sw $t1, 0($t0)      # set the shape at (3, 14)
#     addi $t0, $zero, 63 # (3, 15) at memory = 3 * 16 + 15 = 63   # C
#     sw $t1, 0($t0)      # set the shape at (3, 15)
#     addi $t0, $zero, 78 # (4, 14) at memory = 4 * 16 + 14 = 78   # B
#     sw $t1, 0($t0)      # set the shape at (4, 14)
#     addi $t0, $zero, 79 # (4, 15) at memory = 4 * 16 + 15 = 79   # D
#     sw $t1, 0($t0)      # set the shape at (4, 15)
#     j after_spawn_shape_specific

spawn_shape_o:
    addi $t0, $zero, 62 # (3, 14) at memory = 3 * 16 + 14 = 62   # A
    sw $t1, 0($t0)      # set the shape at (3, 14)
    addi $t0, $zero, 63 # (3, 15) at memory = 3 * 16 + 15 = 63   # C
    sw $t1, 0($t0)      # set the shape at (3, 15)
    addi $t0, $zero, 78 # (4, 14) at memory = 4 * 16 + 14 = 78   # B
    sw $t1, 0($t0)      # set the shape at (4, 14)
    addi $t0, $zero, 79 # (4, 15) at memory = 4 * 16 + 15 = 79   # D
    sw $t1, 0($t0)      # set the shape at (4, 15)
    j after_spawn_shape_specific

spawn_shape_l:
    addi $t0, $zero, 62 # (3, 14) at memory = 3 * 16 + 14 = 62   # A
    sw $t1, 0($t0)      # set the shape at (3, 14)
    addi $t0, $zero, 63 # (3, 15) at memory = 3 * 16 + 15 = 63   # C
    sw $t1, 0($t0)      # set the shape at (3, 15)
    addi $t0, $zero, 78 # (4, 14) at memory = 4 * 16 + 14 = 78   # B
    sw $t1, 0($t0)      # set the shape at (4, 14)
    j after_spawn_shape_specific

spawn_shape_j:
    addi $t0, $zero, 62 # (3, 14) at memory = 3 * 16 + 14 = 62   # A
    sw $t1, 0($t0)      # set the shape at (3, 14)
    addi $t0, $zero, 78 # (4, 14) at memory = 4 * 16 + 14 = 78   # B
    sw $t1, 0($t0)      # set the shape at (4, 14)
    addi $t0, $zero, 79 # (4, 15) at memory = 4 * 16 + 15 = 79   # D
    sw $t1, 0($t0)      # set the shape at (4, 15)
    j after_spawn_shape_specific

spawn_shape_7:
    addi $t0, $zero, 63 # (3, 15) at memory = 3 * 16 + 15 = 63   # C
    sw $t1, 0($t0)      # set the shape at (3, 15)
    addi $t0, $zero, 78 # (4, 14) at memory = 4 * 16 + 14 = 78   # B
    sw $t1, 0($t0)      # set the shape at (4, 14)
    addi $t0, $zero, 79 # (4, 15) at memory = 4 * 16 + 15 = 79   # D
    sw $t1, 0($t0)      # set the shape at (4, 15)
    j after_spawn_shape_specific

spawn_shape_i:
    addi $t0, $zero, 62 # (3, 14) at memory = 3 * 16 + 14 = 62   # A
    sw $t1, 0($t0)      # set the shape at (3, 14)
    addi $t0, $zero, 63 # (3, 15) at memory = 3 * 16 + 15 = 63   # C
    sw $t1, 0($t0)      # set the shape at (3, 15)
    j after_spawn_shape_specific

draw_screen_border_loop:
    sw $t0, 0($io)    # send x to display
    sw $t1, 1($io)    # send y to display
    sw $zero, 2($io)  # update display
    beq $t1, $t2, after_draw_screen_border_loop
    addi $t1, $t1, 1
    j draw_screen_border_loop

exit:
